require 'rubygems'
require 'rdf'

class CoreApiResponseParser

	RESULT_BOOL = 'text/boolean'.freeze # Sesame-specific
	RESULT_JSON = 'application/sparql-results+json'.freeze
	RESULT_XML = 'application/sparql-results+xml'.freeze
	ACCEPT_JSON = {'Accept' => RESULT_JSON}.freeze
	ACCEPT_XML = {'Accept' => RESULT_XML}.freeze

	# Methods below lifted from sparql-client.rb by Arto Bendiken, Ben Lavender and others
	# @see http://sparql.rubyforge.org/client/

	##
	# @param  [Net::HTTPSuccess] response
	# @param  [Hash{Symbol => Object}] options
	# @return [Object]
	def self.parse_response(response, options = {})
		case content_type = options[:content_type] || response.content_type
			when RESULT_BOOL # Sesame-specific
				response.body == 'true'
			when RESULT_JSON
				self.parse_json_bindings(response.body, nodes)
			when RESULT_XML
				self.parse_xml_bindings(response.body, nodes)
			else
				parse_rdf_serialization(response, options)
		end
	end

	##
	# @param  [String, Hash] json
	# @return [Enumerable<RDF::Query::Solution>]
	# @see    http://www.w3.org/TR/rdf-sparql-json-res/#results
	def self.parse_json_bindings(json, nodes = {})
		require 'json' unless defined?(::JSON)
		json = JSON.parse(json.to_s) unless json.is_a?(Hash)

		case
			when json['boolean']
				json['boolean']
			when json['results']
				json['results']['bindings'].map do |row|
					row = row.inject({}) do |cols, (name, value)|
						cols.merge(name.to_sym => parse_json_value(value))
					end
					RDF::Query::Solution.new(row)
				end
		end
	end

	##
	# @param  [Hash{String => String}] value
	# @return [RDF::Value]
	# @see    http://www.w3.org/TR/rdf-sparql-json-res/#variable-binding-results
	def self.parse_json_value(value, nodes = {})
		case value['type'].to_sym
			when :bnode
				nodes[id = value['value']] ||= RDF::Node.new(id)
			when :uri
				RDF::URI.new(value['value'])
			when :literal
				RDF::Literal.new(value['value'], :language => value['xml:lang'])
			when :'typed-literal'
				RDF::Literal.new(value['value'], :datatype => value['datatype'])
			else
				nil
		end
	end

	##
	# @param  [String, REXML::Element] xml
	# @return [Enumerable<RDF::Query::Solution>]
	# @see    http://www.w3.org/TR/rdf-sparql-json-res/#results
	def self.parse_xml_bindings(xml, nodes = {})
		xml.force_encoding(::Encoding::UTF_8) if xml.respond_to?(:force_encoding)
		require 'rexml/document' unless defined?(::REXML::Document)
		xml = REXML::Document.new(xml).root unless xml.is_a?(REXML::Element)

		case
			when boolean = xml.elements['boolean']
				boolean.text == 'true'
			when results = xml.elements['results']
				results.elements.map do |result|
					row = {}
					result.elements.each do |binding|
						name = binding.attributes['name'].to_sym
						value = binding.select { |node| node.kind_of?(::REXML::Element) }.first
						row[name] = parse_xml_value(value, nodes)
					end
					RDF::Query::Solution.new(row)
				end
		end
	end

	##
	# @param  [REXML::Element] value
	# @return [RDF::Value]
	# @see    http://www.w3.org/TR/rdf-sparql-json-res/#variable-binding-results
	def self.parse_xml_value(value, nodes = {})
		case value.name.to_sym
			when :bnode
				nodes[id = value.text] ||= RDF::Node.new(id)
			when :uri
				RDF::URI.new(value.text)
			when :literal
				RDF::Literal.new(value.text, {
					:language => value.attributes['xml:lang'],
					:datatype => value.attributes['datatype'],
				})
			else
				nil
		end
	end

	##
	# @param  [Net::HTTPSuccess] response
	# @param  [Hash{Symbol => Object}] options
	# @return [RDF::Enumerable]
	def parse_rdf_serialization(response, options = {})
		options = {:content_type => response.content_type} if options.empty?
		if reader = RDF::Reader.for(options)
			reader.new(response.body)
		end
	end

	##
	# A mapping of blank node results for this client
	# @private
	def self.nodes
		@nodes ||= {}
	end

end